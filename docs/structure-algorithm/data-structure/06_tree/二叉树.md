---
id: binaryTree
title: 二叉树
---
# 二叉树

## 认识二叉树

### 二叉树的由来

- 树的普通表示方式

  <img src="./images/image-20240128171013263.png" alt="image-20240128171013263" style="zoom: 50%;" />

- 树的==儿子 — 兄弟==表示法（每个节点只记录一个子节点和一个兄弟节点）

  <img src="./images/image-20240128171124282.png" alt="image-20240128171124282" style="zoom: 54%;" />

- 将儿子 — 兄弟表示法旋转，可以得到一个以 A 为 **根** 的二叉树

  <img src="./images/image-20240128171308073.png" alt="image-20240128171308073" style="zoom: 60%;" />

- 通过 **儿子 — 兄弟** 表示法，可以得出一个重要结论：==所有的树结构都可以用 **二叉树** 模拟出来==



### 定义及特性

- 在计算机科学中，二叉树（Binary tree）是每个节点==最多只有两个分支==的树结构

  - 通常分支被称作“左子树”或“右子树”，分支具有左右次序，不能随意颠倒
  - 二叉树可以为空

- 二叉树有五种形态

  <img src="./images/image-20240129110343114.png" alt="image-20240129110343114" style="zoom:60%;" />

  - 空树
  - 只有一个根节点
  - 只有根节点和左子树
  - 只有根节点和右子树
  - 根节点和左右子树均存在

- 二叉树的特性
  - 一个二叉树第 i 层的最大节点数为：`2^(i-1)`（i >= 1）
  - 深度为 k 的二叉树的最大节点总数为： `2^k - 1`（k >= 1）
  - 对任何非空二叉树 T，若 **n0** 表示叶节点的个数、**n2** 是度为 2 的非叶节点个数，那么两者满足关系 `n0 = n2 + 1`



## 特殊的二叉树

### 完美二叉树

- 定义：在二叉树中，除了最下一层的叶节点外，每层节点都有 2 个子节点，就构成了完美二叉树（满二叉树）

  <img src="./images/image-20240129113609744.png" alt="image-20240129113609744" style="zoom: 50%;" />

- 性质：对于一棵深度为 **k** 的完美二叉树

  - 共有 **2^k - 1** 个节点
  - 节点个数一定为==奇数==



### 完全二叉树

- 完全二叉树定义

  - 除二叉树最后一层外，其他各层的节点数都达到最大个数
  - 且最后一层==从左向右的叶节点连续存在==，只缺右侧若干节点

  ![image-20240129114417634](./images/image-20240129114417634.png)

- 完全二叉树的性质

  - 深度为 **k** 的完全二叉树，至少有 **2^(k-1)** 个节点，至多有 **2^k - 1** 个节点
  - ==完美二叉树是特殊的完全二叉树==，反之完全二叉树不一定是完美二叉树



## 二叉树的存储

二叉树的存储常见的方式是 **数组** 或 **链表**

### 数组存储

- 使用数组可以作为二叉树的一种存储方式，即通过==广度优先==顺序存储每一个节点

  - 对于完全二叉树，采用按从上至下、从左到右顺序存储

    <img src="./images/image-20240129151729622.png" alt="image-20240129151729622" style="zoom: 67%;" />

  - 对于非完全二叉树，需要先将其转化成一个完全二叉树，不存在的节点以空值代替，再进行顺序存储

    <img src="./images/image-20240129151851128.png" alt="image-20240129151851128" style="zoom:80%;" />

- 根据上述分析可知
  - 如果是完全二叉树，使用数组存储无疑是最节省内存的一种方式
  - 如果是非完全二叉树，其实会浪费比较多的数组存储空间



### 链表存储

- 为了减少存储空间的浪费，提高存储的灵活性，存储二叉树通常使用 **链表**

- 每个链表节点包含三个字段

  <img src="./images/20220403212249.png" alt="img" style="zoom:80%;" />

  - 其中 `data` 存储节点数据
  - 另外两个 — `left` 和 `right`，分别存储左右子树的==指针==



## 二叉树的遍历

### 先序遍历

**先序** 遍历规定==先访问根节点==，再访问其左子树，最后访问右子树

<img src="./images/image-20240129163329776.png" alt="image-20240129163329776" style="zoom: 60%;" />



### 中序遍历

**中序** 遍历规定==先访问左子树==，再访问其根节点，最后访问右子树

<img src="./images/image-20240129174052665.png" alt="image-20240129174052665" style="zoom:60%;" />



### 后序遍历

**后序** 遍历规定==先访问左子树==，再访问其右子树，最后访问根节点

<img src="./images/image-20240129172803969.png" alt="image-20240129172803969" style="zoom:60%;" />



### 层序遍历

**层序** 遍历以==从上至下、从左至右==的方式进行访问

<img src="./images/image-20240129173636253.png" alt="image-20240129173636253" style="zoom:60%;" />



## 二叉搜索树

### 认识二叉搜索树

- **二叉搜索树**（Binary Search Tree），也称二叉排序树或二叉查找树

- 二叉搜索树是一颗二叉树，可以为空；如果不为空，满足以下性质

  - 非空==左子树==的所有键值==小于==其根节点的键值
  - 非空==右子树==的所有键值==大于==其根节点的键值
  - 左、右子树本身也属于二叉搜索树

  <img src="./images/image-20240129225940251.png" alt="image-20240129225940251" style="zoom: 67%;" />

- 二叉查找树相比于其他数据结构的优势在于==查找==、==插入==的时间复杂度较低，为 `O(log n)`
  - 相对==较小==的值总是保存在==左节点==上，相对==较大==的值总是保存在==右节点==上



### 封装二叉搜索树

#### 初始化 BST 结构

- 准备一个 `TreeNode` 类，用于保存每个节点的信息

  ```typescript
  /**
   * @description 树节点
   */
  class TreeNode<T> {
    /**
     * @description 节点的值
     */
    value: T;
    /**
     * @description 左子树
     */
    left: TreeNode<T> | null = null;
    /**
     * @description 右子树
     */
    right: TreeNode<T> | null = null;
  
    constructor(value: T) {
      this.value = value;
    }
  }
  ```

- 定义二叉搜索树类，包含一个根节点 `root`

  ```typescript
  /**
   * @description 二叉搜索树
   */
  class BSTree<T> {
    /**
     * @description 根节点
     */
    root: TreeNode<T> | null = null;
  }
  ```
